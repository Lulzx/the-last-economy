<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Network Prison</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300;1,400;1,500&family=DM+Sans:ital,opsz,wght@0,9..40,100..900;1,9..40,100..900&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
body { background: #fafaf8; color: #1a1a1a; font-family: 'DM Sans', system-ui, sans-serif; margin: 0; }
.prose { max-width: 680px; margin: 0 auto; padding: 2rem 1.5rem; font-family: 'DM Sans', system-ui, sans-serif; line-height: 1.7; font-size: 1.05rem; }
.scrub { border-bottom: 2px dashed #2563eb; color: #2563eb; cursor: ew-resize; user-select: none; font-weight: 600; padding: 0 2px; }
.panel { background: white; border: 1px solid #e5e5e0; border-radius: 8px; padding: 1.5rem; margin: 2rem 0; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
h1 { font-family: 'Playfair Display', Georgia, serif; font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem; }
h2 { font-family: 'Playfair Display', Georgia, serif; font-size: 1.3rem; font-weight: 600; margin-top: 2rem; }
.chapter-num { color: #888; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; }
.nav { display: flex; justify-content: space-between; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e5e0; font-size: 0.9rem; }
.nav a { color: #2563eb; text-decoration: none; }
.nav a:hover { text-decoration: underline; }
svg text { font-family: 'DM Sans', system-ui, sans-serif; }
.btn { background: #2563eb; color: white; border: none; padding: 0.5rem 1.2rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem; margin: 0.25rem; font-family: 'DM Sans', system-ui, sans-serif; }
.btn:hover { background: #1d4ed8; }
.btn.active { background: #2563eb; color: white; box-shadow: 0 0 0 2px #93c5fd; }
.btn-group { display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0; }
.stat { font-size: 0.9rem; color: #555; margin: 0.5rem 0; }
.stat strong { color: #1a1a1a; }
.gini-display { font-size: 1.8rem; font-weight: 700; color: #2563eb; text-align: center; margin: 0.5rem 0; }
input[type="range"] { width: 100%; margin: 0.5rem 0; accent-color: #2563eb; }
.slider-label { display: flex; justify-content: space-between; font-size: 0.85rem; color: #555; }
.toggle-container { display: flex; align-items: center; gap: 1rem; margin: 1rem 0; }
.toggle { position: relative; width: 52px; height: 28px; background: #ccc; border-radius: 14px; cursor: pointer; transition: background 0.3s; }
.toggle.on { background: #2563eb; }
.toggle::after { content: ''; position: absolute; top: 2px; left: 2px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: transform 0.3s; }
.toggle.on::after { transform: translateX(24px); }
.caption { font-size: 0.9rem; color: #666; font-style: italic; margin-top: 1rem; }
</style>
</head>
<body>
<nav class="nav">
  <a href="06-three-flows.html">&larr; Previous</a>
  <a href="explorables.html">All Chapters</a>
  <a href="08-cooperation-emerges.html">Next &rarr;</a>
</nav>

<div class="prose">
  <div class="chapter-num">Chapter 10</div>
  <h1>The Network Prison</h1>

  <p>Individual talent matters far less than where you sit in the network. This has always been true. AI makes it absolute. The network topology &mdash; not your skills &mdash; determines your economic fate.</p>

  <!-- Panel 1: Network Builder -->
  <div class="panel">
    <h2>Network Builder &mdash; Power Law Emerges</h2>
    <p style="font-size:0.9rem; color:#666; margin-bottom:1rem;">Click the canvas to add nodes (up to 30). Each new node preferentially attaches to well-connected nodes.</p>
    <div id="builder-svg-container" style="width:100%; max-width:600px;">
      <svg id="builder-svg" style="border:1px solid #e5e5e0; border-radius:6px; cursor:crosshair; display:block; width:100%;"></svg>
    </div>
    <div id="builder-stats" class="stat"></div>
    <div id="builder-hist-container" style="width:100%; max-width:600px;">
      <svg id="builder-hist" style="display:block; width:100%;"></svg>
    </div>
    <p class="caption">No one commanded this hierarchy. Physics created it.</p>
  </div>

  <!-- Panel 2: Three Topology Switcher -->
  <div class="panel">
    <h2>Three Topology Switcher</h2>
    <div class="btn-group">
      <button class="btn active" onclick="switchTopology('hub')">Hub-and-Spoke</button>
      <button class="btn" onclick="switchTopology('smallworld')">Small-World</button>
      <button class="btn" onclick="switchTopology('mesh')">Mesh</button>
    </div>
    <div style="display:flex; gap:1rem; flex-wrap:wrap;">
      <svg id="topo-svg" width="360" height="360" style="flex-shrink:0; max-width:100%;"></svg>
      <div style="flex:1; min-width:200px;">
        <div class="gini-display">Gini: <span id="topo-gini">0.00</span></div>
        <svg id="topo-hist" width="220" height="200" style="max-width:100%;"></svg>
      </div>
    </div>
  </div>

  <!-- Panel 3: Position Slider -->
  <div class="panel">
    <h2>Position Slider</h2>
    <p style="font-size:0.9rem; color:#666;">Same person. Same talent. Different position.</p>
    <div id="pos-svg-container" style="width:100%; max-width:600px;">
      <svg id="pos-svg" style="display:block; width:100%;"></svg>
    </div>
    <div class="slider-label"><span>Periphery</span><span>Center</span></div>
    <input type="range" id="pos-slider" min="0" max="100" value="10">
    <div id="pos-stat" class="stat" style="font-size:1.1rem; text-align:center;"></div>
  </div>

  <!-- Panel 4: AI Amplification -->
  <div class="panel">
    <h2>AI Amplification</h2>
    <div class="toggle-container">
      <span>Pre-AI Era</span>
      <div class="toggle" id="ai-toggle" onclick="toggleAI()"></div>
      <span>AI Era</span>
    </div>
    <div id="ai-svg-container" style="width:100%; max-width:600px;">
      <svg id="ai-svg" style="display:block; width:100%;"></svg>
    </div>
    <div id="ai-stats" class="stat" style="text-align:center; font-size:1.1rem;"></div>
    <p class="caption">AI amplifies existing network advantages. Topology becomes destiny.</p>
  </div>
</div>

<script>
// ========== Panel 1: Network Builder ==========
(function(){
  const container = document.getElementById('builder-svg-container');
  const svg = d3.select('#builder-svg');
  let w = container.clientWidth, h = Math.round(w * 400 / 600);
  svg.attr('viewBox', `0 0 ${w} ${h}`);
  let nodes = [], links = [];
  const sim = d3.forceSimulation()
    .force('charge', d3.forceManyBody().strength(-80))
    .force('center', d3.forceCenter(w/2, h/2))
    .force('link', d3.forceLink().id((d,i)=>i).distance(60))
    .force('collide', d3.forceCollide(15))
    .on('tick', tickBuilder);

  const linkG = svg.append('g');
  const nodeG = svg.append('g');

  svg.on('click', function(event) {
    if (nodes.length >= 30) return;
    const [mx, my] = d3.pointer(event);
    const newNode = { x: mx, y: my };
    const newIdx = nodes.length;

    if (nodes.length >= 2) {
      const degrees = nodes.map((_, i) => links.filter(l => l.source.index === i || l.target.index === i).length + 1);
      const total = d3.sum(degrees);
      const targets = new Set();
      while (targets.size < Math.min(2, nodes.length)) {
        let r = Math.random() * total, cum = 0;
        for (let i = 0; i < degrees.length; i++) {
          cum += degrees[i];
          if (r <= cum) { targets.add(i); break; }
        }
      }
      targets.forEach(t => links.push({ source: newIdx, target: t }));
    } else if (nodes.length === 1) {
      links.push({ source: newIdx, target: 0 });
    }

    nodes.push(newNode);
    sim.nodes(nodes);
    sim.force('link').links(links);
    sim.alpha(0.5).restart();
    updateBuilder();
  });

  function updateBuilder() {
    const linkSel = linkG.selectAll('line').data(links);
    linkSel.enter().append('line').attr('stroke', '#ccc').attr('stroke-width', 1.5);
    linkSel.exit().remove();

    const nodeSel = nodeG.selectAll('circle').data(nodes);
    nodeSel.enter().append('circle').attr('r', 6).attr('fill', '#2563eb').attr('stroke', '#fff').attr('stroke-width', 1.5);
    nodeSel.exit().remove();

    const degrees = nodes.map((_, i) => links.filter(l => (l.source.index ?? l.source) === i || (l.target.index ?? l.target) === i).length);
    if (degrees.length) {
      const maxDeg = d3.max(degrees) || 1;
      const minDeg = d3.min(degrees) || 0;
      d3.select('#builder-stats').html(`Most connected node has <strong>${maxDeg}</strong> connections. Least connected: <strong>${minDeg}</strong>.`);
      drawHist('#builder-hist', degrees, w, 120);
    }
  }

  function tickBuilder() {
    linkG.selectAll('line')
      .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
    nodeG.selectAll('circle')
      .attr('cx', d => d.x).attr('cy', d => d.y);
  }

  function drawHist(sel, degrees, w, h) {
    const svg = d3.select(sel);
    svg.attr('viewBox', `0 0 ${w} ${h}`);
    svg.selectAll('*').remove();
    const maxDeg = d3.max(degrees) || 1;
    const bins = Array(maxDeg + 1).fill(0);
    degrees.forEach(d => bins[d]++);
    const x = d3.scaleBand().domain(d3.range(bins.length)).range([30, w - 10]).padding(0.2);
    const y = d3.scaleLinear().domain([0, d3.max(bins)]).range([h - 20, 5]);
    svg.selectAll('rect').data(bins).enter().append('rect')
      .attr('x', (d,i) => x(i)).attr('y', d => y(d))
      .attr('width', x.bandwidth()).attr('height', d => h - 20 - y(d))
      .attr('fill', '#2563eb').attr('rx', 2);
    svg.append('text').attr('x', w/2).attr('y', h - 2).attr('text-anchor', 'middle').attr('font-size', 11).attr('fill', '#888').text('Degree distribution');
  }
  window.drawHist = drawHist;

  window.addEventListener('resize', function() {
    w = container.clientWidth; h = Math.round(w * 400 / 600);
    svg.attr('viewBox', `0 0 ${w} ${h}`);
    sim.force('center', d3.forceCenter(w/2, h/2));
    sim.alpha(0.3).restart();
  });
})();

// ========== Panel 2: Topology Switcher ==========
(function(){
  const N = 50;
  const topoSvg = d3.select('#topo-svg');
  const tw = 360, th = 360;
  let currentTopo = 'hub';

  function generateTopology(type) {
    const nodes = d3.range(N).map(i => ({ id: i }));
    const links = [];
    if (type === 'hub') {
      for (let i = 1; i < N; i++) links.push({ source: 0, target: i });
      for (let i = 1; i < N; i++) { if (Math.random() < 0.1 && i + 1 < N) links.push({ source: i, target: i + 1 }); }
    } else if (type === 'smallworld') {
      for (let i = 0; i < N; i++) {
        links.push({ source: i, target: (i + 1) % N });
        links.push({ source: i, target: (i + 2) % N });
      }
      for (let i = 0; i < 8; i++) {
        links.push({ source: Math.floor(Math.random() * N), target: Math.floor(Math.random() * N) });
      }
    } else {
      for (let i = 0; i < N; i++) {
        links.push({ source: i, target: (i + 1) % N });
        links.push({ source: i, target: (i + 2) % N });
      }
    }
    return { nodes, links };
  }

  function computeScores(type, nodes, links) {
    const degrees = nodes.map((_, i) => links.filter(l => (l.source.id ?? l.source) === i || (l.target.id ?? l.target) === i).length);
    if (type === 'hub') {
      return nodes.map((_, i) => i === 0 ? 95 : 0.1 + Math.random() * 0.8);
    } else if (type === 'smallworld') {
      return nodes.map((_, i) => {
        const d = degrees[i];
        if (d >= 6) return 30 + Math.random() * 10;
        if (d >= 4) return 10 + Math.random() * 10;
        return 5 + Math.random() * 5;
      });
    } else {
      return nodes.map(() => 15 + Math.random() * 10);
    }
  }

  function gini(vals) {
    const sorted = [...vals].sort((a, b) => a - b);
    const n = sorted.length;
    let num = 0;
    sorted.forEach((v, i) => num += (2 * (i + 1) - n - 1) * v);
    const den = n * d3.sum(sorted);
    return den === 0 ? 0 : num / den;
  }

  function renderTopology(type) {
    currentTopo = type;
    document.querySelectorAll('.panel .btn-group .btn').forEach(b => {
      b.classList.toggle('active', b.textContent.toLowerCase().includes(type === 'hub' ? 'hub' : type === 'smallworld' ? 'small' : 'mesh'));
    });

    const { nodes, links } = generateTopology(type);
    const scores = computeScores(type, nodes, links);
    const g = gini(scores);

    d3.select('#topo-gini').text(g.toFixed(2));

    nodes.forEach((n, i) => {
      const angle = (2 * Math.PI * i) / N - Math.PI / 2;
      n.x = tw / 2 + Math.cos(angle) * 140;
      n.y = th / 2 + Math.sin(angle) * 140;
    });
    if (type === 'hub') { nodes[0].x = tw / 2; nodes[0].y = th / 2; }

    topoSvg.selectAll('*').remove();
    topoSvg.selectAll('line').data(links).enter().append('line')
      .attr('x1', d => nodes[d.source].x).attr('y1', d => nodes[d.source].y)
      .attr('x2', d => nodes[d.target].x).attr('y2', d => nodes[d.target].y)
      .attr('stroke', '#ddd').attr('stroke-width', 0.8);
    topoSvg.selectAll('circle').data(nodes).enter().append('circle')
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('r', (d, i) => 3 + scores[i] / 8)
      .attr('fill', (d, i) => d3.interpolateBlues(scores[i] / 100))
      .attr('stroke', '#fff').attr('stroke-width', 1);

    const histSvg = d3.select('#topo-hist');
    histSvg.selectAll('*').remove();
    const hw = 220, hh = 200;
    const buckets = [0, 5, 10, 20, 30, 50, 100];
    const bins = Array(buckets.length - 1).fill(0);
    scores.forEach(s => { for (let i = 0; i < buckets.length - 1; i++) { if (s >= buckets[i] && s < buckets[i + 1]) { bins[i]++; break; } } });
    const x = d3.scaleBand().domain(d3.range(bins.length)).range([30, hw - 5]).padding(0.15);
    const y = d3.scaleLinear().domain([0, d3.max(bins) || 1]).range([hh - 25, 5]);
    histSvg.selectAll('rect').data(bins).enter().append('rect')
      .attr('x', (d, i) => x(i)).attr('y', d => y(d))
      .attr('width', x.bandwidth()).attr('height', d => hh - 25 - y(d))
      .attr('fill', '#2563eb').attr('rx', 2);
    const labels = ['0-5%', '5-10%', '10-20%', '20-30%', '30-50%', '50%+'];
    histSvg.selectAll('.lab').data(labels).enter().append('text')
      .attr('x', (d, i) => x(i) + x.bandwidth() / 2).attr('y', hh - 8)
      .attr('text-anchor', 'middle').attr('font-size', 9).attr('fill', '#888').text(d => d);
    histSvg.append('text').attr('x', hw / 2).attr('y', hh).attr('text-anchor', 'middle').attr('font-size', 10).attr('fill', '#aaa').text('Income share');
  }

  window.switchTopology = renderTopology;
  renderTopology('hub');
})();

// ========== Panel 3: Position Slider ==========
(function(){
  const container = document.getElementById('pos-svg-container');
  const svg = d3.select('#pos-svg');
  let w = container.clientWidth, h = Math.round(w * 300 / 600);
  svg.attr('viewBox', `0 0 ${w} ${h}`);
  const N = 30;
  const nodes = d3.range(N).map(i => ({ id: i }));
  const links = [];
  for (let i = 0; i < N; i++) {
    links.push({ source: i, target: (i + 1) % N });
    links.push({ source: i, target: (i + 2) % N });
  }
  links.push({ source: 0, target: 15 });
  links.push({ source: 5, target: 20 });

  const pickedNode = 0;
  let extraLinks = [];

  function render(position) {
    const pct = position / 100;
    extraLinks = [];
    const numExtra = Math.floor(pct * 12);
    for (let i = 0; i < numExtra; i++) {
      const t = Math.floor((i + 1) * N / (numExtra + 1)) % N;
      if (t !== pickedNode) extraLinks.push({ source: pickedNode, target: t });
    }
    const allLinks = [...links, ...extraLinks];
    const myDeg = allLinks.filter(l => l.source === pickedNode || l.target === pickedNode).length;
    const baseDeg = 2;
    const multiplier = (myDeg / baseDeg).toFixed(1);

    nodes.forEach((n, i) => {
      const angle = (2 * Math.PI * i) / N - Math.PI / 2;
      const r = i === pickedNode ? (1 - pct) * 120 + 10 : 120;
      n.x = w / 2 + Math.cos(angle) * r;
      n.y = h / 2 + Math.sin(angle) * r;
    });

    svg.selectAll('*').remove();
    svg.selectAll('line').data(allLinks).enter().append('line')
      .attr('x1', d => nodes[d.source].x).attr('y1', d => nodes[d.source].y)
      .attr('x2', d => nodes[d.target].x).attr('y2', d => nodes[d.target].y)
      .attr('stroke', d => (d.source === pickedNode || d.target === pickedNode) ? '#2563eb44' : '#e5e5e0')
      .attr('stroke-width', d => (d.source === pickedNode || d.target === pickedNode) ? 2 : 1);
    svg.selectAll('circle').data(nodes).enter().append('circle')
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('r', (d, i) => i === pickedNode ? 10 : 5)
      .attr('fill', (d, i) => i === pickedNode ? '#2563eb' : '#ccc')
      .attr('stroke', '#fff').attr('stroke-width', 1.5);
    svg.append('text').attr('x', nodes[pickedNode].x).attr('y', nodes[pickedNode].y - 16)
      .attr('text-anchor', 'middle').attr('font-size', 12).attr('fill', '#2563eb').attr('font-weight', 600).text('You');

    d3.select('#pos-stat').html(`Same person. Same talent. Different position. Outcome changes <strong>${multiplier}&times;</strong>.`);
  }

  d3.select('#pos-slider').on('input', function() { render(+this.value); });
  render(10);

  window.addEventListener('resize', function() {
    w = container.clientWidth; h = Math.round(w * 300 / 600);
    svg.attr('viewBox', `0 0 ${w} ${h}`);
    render(+document.getElementById('pos-slider').value);
  });
})();

// ========== Panel 4: AI Amplification ==========
(function(){
  const container = document.getElementById('ai-svg-container');
  const svg = d3.select('#ai-svg');
  let w = container.clientWidth, h = Math.round(w * 350 / 600);
  svg.attr('viewBox', `0 0 ${w} ${h}`);
  const N = 40;
  let aiMode = false;

  function buildNetwork() {
    const nodes = d3.range(N).map(i => ({ id: i }));
    const links = [];
    for (let i = 3; i < N; i++) {
      const hub = Math.random() < 0.6 ? Math.floor(Math.random() * 3) : Math.floor(Math.random() * i);
      links.push({ source: hub, target: i });
    }
    for (let i = 0; i < 3; i++) { for (let j = i + 1; j < 3; j++) links.push({ source: i, target: j }); }
    return { nodes, links };
  }

  const { nodes, links } = buildNetwork();

  function render() {
    const allLinks = [...links];
    if (aiMode) {
      for (let i = 0; i < 3; i++) {
        for (let j = 3; j < N; j += 3) {
          if (!allLinks.find(l => (l.source === i && l.target === j) || (l.source === j && l.target === i)))
            allLinks.push({ source: i, target: j });
        }
      }
    }

    const degrees = nodes.map((_, i) => allLinks.filter(l => l.source === i || l.target === i).length);
    const maxDeg = d3.max(degrees) || 1;

    nodes.forEach((n, i) => {
      const angle = (2 * Math.PI * i) / N - Math.PI / 2;
      const isHub = i < 3;
      const r = isHub ? 40 : 130 + Math.random() * 20;
      n.x = w / 2 + Math.cos(angle) * r;
      n.y = h / 2 + Math.sin(angle) * r;
    });

    svg.selectAll('*').remove();
    svg.selectAll('line').data(allLinks).enter().append('line')
      .attr('x1', d => nodes[d.source].x).attr('y1', d => nodes[d.source].y)
      .attr('x2', d => nodes[d.target].x).attr('y2', d => nodes[d.target].y)
      .attr('stroke', '#e5e5e0').attr('stroke-width', 0.5);

    const rScale = aiMode
      ? d3.scaleSqrt().domain([0, maxDeg]).range([2, 30])
      : d3.scaleSqrt().domain([0, maxDeg]).range([4, 14]);

    svg.selectAll('circle').data(nodes).enter().append('circle')
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('r', (d, i) => rScale(degrees[i]))
      .attr('fill', (d, i) => i < 3 ? '#2563eb' : '#ccc')
      .attr('opacity', (d, i) => aiMode && i >= 3 ? 0.4 : 0.9)
      .attr('stroke', '#fff').attr('stroke-width', 1);

    const humanRelevance = aiMode ? 23 : 100;
    const hubShare = aiMode ? '87%' : '42%';
    d3.select('#ai-stats').html(
      `Human relevance: <strong>${humanRelevance}%</strong> &nbsp;&middot;&nbsp; Hub value share: <strong>${hubShare}</strong>`
    );
  }

  window.toggleAI = function() {
    aiMode = !aiMode;
    d3.select('#ai-toggle').classed('on', aiMode);
    render();
  };
  render();

  window.addEventListener('resize', function() {
    w = container.clientWidth; h = Math.round(w * 350 / 600);
    svg.attr('viewBox', `0 0 ${w} ${h}`);
    render();
  });
})();
</script>
</body>
</html>
